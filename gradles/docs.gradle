/*
 * Copyright 2002-2017 the original author or authors.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

apply plugin: "org.asciidoctor.convert"

asciidoctor {
	sources {
		include '*.adoc'
	}
	logDocuments = true
	backends = ["html5", "pdf"]
	options doctype: 'book', eruby: 'erubis'
	attributes  'icons': 'font',
				'idprefix': '',
				'idseparator': '-',
				docinfo: '',
				revnumber: project.version,
				sectanchors: '',
				sectnums: '',
				'source-highlighter': 'coderay@', // TODO switch to 'rouge' once supported by the html5 backend
				stylesdir: 'stylesheets/',
				stylesheet: 'spring.css',
				'spring-version': project.version

}

task api(type: Javadoc) {
	group = "Documentation"
	description = "Generates aggregated Javadoc API documentation."
	title = "${rootProject.description} ${version} API"

	dependsOn {
		subprojects.collect {
			it.tasks.getByName("jar")
		}
	}
	options.memberLevel = org.gradle.external.javadoc.JavadocMemberLevel.PROTECTED
	options.author = true
	options.encoding="UTF-8"
	options.header = rootProject.description
	options.overview = "${quicksand_sdk_home}/var/docs/api/overview.html"
	options.stylesheetFile = file("${quicksand_sdk_home}/var/docs/api/stylesheet.css")
	options.splitIndex = true
	//options.links(project.ext.javadocLinks)
	options.addStringOption('Xdoclint:none', '-quiet')

	source subprojects.collect { project ->
		project.sourceSets.main.allJava
	}

	maxMemory = "1024m"
	destinationDir = new File(buildDir, "api")

	doFirst {
		classpath += files(subprojects.collect { it.sourceSets.main.compileClasspath })
	}
}

task docsZip(type: Zip, dependsOn: 'asciidoctor') {
	group = "Distribution"
	baseName = "Quicksand-framework"
	classifier = "docs"
	description = "Builds -${classifier} archive containing api and reference "

	from("var/dist") {
		include "changelog.txt"
	}

	from (api) {
		into "javadoc-api"
	}

	from (asciidoctor) {
		into "Quicksand-framework-reference"
	}
}


task distZip(type: Zip, dependsOn: [docsZip]) {
	group = "Distribution"
	baseName = "spring-framework"
	classifier = "dist"
	description = "Builds -${classifier} archive, containing all jars and docs, " +
			"suitable for community download page."

	ext.baseDir = "${baseName}-${project.version}";

	from("var/docs/dist") {
		include "readme.txt"
		include "license.txt"
		include "notice.txt"
		into "${baseDir}"
		expand(copyright: new Date().format("yyyy"), version: project.version)
	}

	from(zipTree(docsZip.archivePath)) {
		into "${baseDir}/docs"
	}
	moduleProjects.each { subproject ->
		into ("${baseDir}/libs") {
			from subproject.jar
			if (subproject.tasks.findByPath("sourcesJar")) {
				from subproject.sourcesJar
			}
			if (subproject.tasks.findByPath("javadocJar")) {
				from subproject.javadocJar
			}
		}
	}
}

// Create a distribution that contains all dependencies (required and optional).
// Not published by default; only for use when building from source.
task depsZip(type: Zip, dependsOn: distZip) { zipTask ->
	group = "Distribution"
	baseName = "spring-framework"
	classifier = "dist-with-deps"
	description = "Builds -${classifier} archive, containing everything " +
			"in the -${distZip.classifier} archive plus all runtime dependencies."

	from zipTree(distZip.archivePath)

	gradle.taskGraph.whenReady { taskGraph ->
		if (taskGraph.hasTask(":${zipTask.name}")) {
			def projectNames = rootProject.subprojects*.name
			def artifacts = new HashSet()
			subprojects.each { subproject ->
				(subproject.configurations.runtime.resolvedConfiguration.resolvedArtifacts +
						subproject.configurations.optional.resolvedConfiguration.resolvedArtifacts).each { artifact ->
					def dependency = artifact.moduleVersion.id
					if (!projectNames.contains(dependency.name)) {
						artifacts << artifact.file
					}
				}
			}

			zipTask.from(artifacts) {
				into "${distZip.baseDir}/deps"
			}
		}
	}
}